//https://www.luogu.com.cn/problem/P1004
//这里的关键是要考虑到两条路径的所有可能的走法，并比较它们以找到最大和。
#include<bits/stdc++.h>
using namespace std;
#define maxn 20
int f[maxn][maxn][maxn][maxn];
//声明了一个四维数组 f，它的作用是存储动态规划过程中的中间结果，
//以避免重复计算子问题的解。这种技术通常被称为“记忆化”或“备忘录”。
//这个四维数组的每个维度代表：
//
//第一个维度 x：第一个路径的当前行位置。
//第二个维度 y：第一个路径的当前列位置。
//第三个维度 x2：第二个路径的当前行位置。
//第四个维度 y2：第二个路径的当前列位置。
//通过这种方式，我们可以确保每个路径组合的 最大和 只被计算一次，并且存储在 f 数组中 以供后续使用。
//当我们在 dfs 函数中计算出一个新的最大和时，我们就将其存储在 f[x][y][x2][y2] 中，
//这样如果 dfs 函数再次被调用以计算相同的路径组合，它可以直接返回存储在 f 中的值，而不需要重新计算。
int s[maxn][maxn];
int N = 0;
//两种方案同时进行；
//有四种进行方式
int dfs(int x,int y,int x2,int y2) {
	if (f[x][y][x2][y2] != -1) return f[x][y][x2][y2];
	//使用 记忆化 技术（即检查 f[x][y][x2][y2] 是否已经被计算过）来避免重复计算,节省时间，防止超时
	if (x == N && y == N && x2 == N && y2 == N) return 0;
	//如果两种方案都走到了终点，返回结束
	int M = 0;	
	//如果两种方案都不在最后一行，就都往下走，统计取得的数，如果有重复，就减去一部分
	//(x + 1 == x2 + 1 && y == y2) 用来判断两种方案是不是走到了同一格的 如果重复 为1 则- s[x + 1][y] * 1; 否则为0, - 0;
	//1.	同时向下
	if(x < N && x2 < N) M = max(M, dfs(x + 1, y, x2 + 1, y2) + s[x + 1][y] + s[x2 + 1][y2] - s[x + 1][y] * (x + 1 == x2 + 1 && y == y2));
	//如果两种方案都不在最后一列 
	//2.	就都向右
	if (y < N && y2 < N) M = max(M, dfs(x, y + 1, x2, y2 + 1) + s[x][y + 1] + s[x2][y2 + 1] - s[x][y + 1] * (x == x2 && y + 1 == y2 + 1));
	//如果1的x不在最后一行 2的y2不在最后一列 
	//3.	1向下 2向右
	if (x < N && y < N) M = max(M, dfs(x + 1, y, x2, y2 + 1) + s[x + 1][y] + s[x2][y2 + 1] - s[x + 1][y] * (x + 1 == x2 && y == y2 + 1));
	//如果1的y不在最后一列 2的x2不在最后一行 
	//4.	1向右 2向下
	if (y < N && x2 < N) M = max(M, dfs(x, y + 1, x2 + 1, y2) + s[x][y + 1] + s[x2 + 1][y2] - s[x][y + 1] * (x == x2 + 1 && y + 1 == y2));
	
	f[x][y][x2][y2] = M;//到达给该处路径的最大值进行更新
	//f[x][y][x2][y2] 的值代表了从起点 (1,1) 到 (x,y) 和从起点 (1,1) 到 (x2,y2) 的两条路径上取得的最大收益。

	return M;
}
int main() {
	cin >> N;
	memset(f, -1,sizeof(f));
	for (; ;) {
		int t1, t2, t3;
		cin >> t1 >> t2 >> t3;
		if (t1 == 0 && t2 == 0 && t3 == 0) {
			break;
		}
		s[t1][t2] = t3;
	}
	cout << dfs(1, 1, 1, 1) + s[1][1];
	return 0;
 }
